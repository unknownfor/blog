[{"title":"webview更新地址没有发起请求","url":"%2F2018%2F08%2F14%2Fwebview%E6%9B%B4%E6%96%B0%E5%9C%B0%E5%9D%80%E6%B2%A1%E6%9C%89%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%2F","content":"\n#### 场景\n\napp启动的时候会预加载web页面，web页面依赖app的相关权限数据（例如aoo定位坐标）\n\n1. 首次进入app，用户据胡娥授权定位或者手机定位未开启，这时候web页面已经预加载。(以hash路由为例)\n\n```\nhttps://www.baidu.com/index.html#/\n```\n\n获取不到定位，页面先加载北京的数据。\n\n2. 用户开启手机定位，app获取到经纬度，重新请求一次接口，url地址为\n\n```\nhttps://www.baidu.com/index.html#/?lat=143.232232&lon=32.234432\n```\n\n#### 问题\n\nurl更新并没有请求接口更新数据\n\n#### 解决问题\n\n利用watch监听router中query的变化\n\n```\nwatch: {\n      '$route' (to, from) { //监听路由是否变化\n          if(to.query.lat != from.query.lat){\n              this.loadData();//重新加载数据\n          }\n      }\n}\n```\n\nAPP加载的一直是`https://www.baidu.com/index.html#/`这个地址，只是后边追加的参数不同，再回想下vue单页面路由的原理，只有访问到对应的路由才会触发对应的页面加载（当前路由和要跳转的路由对应同一个组件时，组件不会被更新，生命周期不会被执行），才会触发页面中的vue的生命周期，所以，可以利用watch来监听路由参数的变化。\n\n\n#### 参考文章 \n- [官方说明](https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96)","tags":["移动端"]},{"title":"学习单元测试 - Jest","url":"%2F2018%2F05%2F04%2F%E5%AD%A6%E4%B9%A0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%20-%20Jest%2F","content":"\n现在系统功能趋于稳定，想着接入单元测试使用一下。尝试着为公共组件和公共方法编写覆盖全面的单元测试。\n\n# Jest\n\nvue-cli 自带Jest,开箱即用。在根目录中创建一个名为 jest.config.js 的配置文件。[配置文档](https://doc.ebichu.cc/jest/docs/zh-Hans/configuration.html)\n\n```\nmodule.exports = {\n  // 文件后缀\n  moduleFileExtensions: ['js', 'jsx', 'json', 'vue'],\n  // 文件如何转换\n  transform: {\n    '^.+\\\\.vue$': 'vue-jest',\n    '.+\\\\.(css|styl|less|sass|scss|svg|png|jpg|ttf|woff|woff2)$':\n      'jest-transform-stub',\n    '^.+\\\\.jsx?$': 'babel-jest'\n  },\n  // 忽略的文件\n  transformIgnorePatterns: ['/node_modules/'],\n  // 生成快照需要的插件\n  snapshotSerializers: ['jest-serializer-vue'],\n  // 需要执行哪些目录下的测试用例\n  testMatch: [\n    '**/tests/unit/**/*.spec.(js|jsx|ts|tsx)|**/__tests__/*.(js|jsx|ts|tsx)'\n  ],\n  // 在执行用例前的配置文件\n  setupFiles: ['./tests/setup.js'],\n  // 测试覆盖率配置\n  collectCoverage: true,\n  coverageReporters: ['html', 'lcov', 'text-summary'],\n  coverageDirectory: './test/coverage',\n  collectCoverageFrom: ['components/**/*.vue']\n}\n```\n\n安装\n```\nvue add unit-jest\n```\n\n# 语法\n\n断言、异步代码测试、Mock 函数、快照[参考文档](https://jestjs.io/docs/zh-Hans/expect)\n\n异步获取数据肯定是一个常见场景了。异步代码通常会有两种写法，分别为：\n\n- 回调函数\n- 函数返回 promise\n\n在测试异步代码的时候，通常返回的数据是不确定的，因此我们只需要测试异步代码是否正常返回数据即可。\n\n```\n// 回调函数的写法，通过 done 来让测试代码一直等待\ntest('fetch success', done => {\n  fetch(data => {\n    expect(data.success).toBe(true)\n    done()\n  })\n})\n// 函数返回 promise 的写法，注意要加上 return\n// 当然对于返回 promise 的函数我们也可以直接使用 await\ntest('fetch success', () => {\n  return fetch().then(data => {\n    expect(data.success).toBe(true)\n  })\n})\n\n```\n\n# 实践\n\n单元测试case部署在`tests/unit`文件夹中，使用`Jest`编写。可以测试引入的公共方法，也可以测试一个单文件组件。建议按照代码组织结构来编写对应的单元测试case。\n\n使用`npm run unit`来运行单元测试，测试结果会在命令行中显示。在构建**测试环境**的时候会自动运行单元测试，如果单元测试存在未通过的case，则构建会失败并终止。构建beta环境和生产环境暂时不会运行单元测试。\n\n一个简单的关于为数字加入千位分隔符的方法的单元测试：\n\n```javascript\ndescribe('Utils suits', function () {\n  it('should add commas for numbers', function () {\n    let fn = Utils.addNumberCommas\n    expect(fn(123)).toBe('123')\n    expect(fn(12345)).toBe('12,345')\n    expect(fn(1234567.89)).toBe('1,234,567.89')\n    expect(fn(-1234567.89)).toBe('-1,234,567.89')\n  })\n})\n```\n\n输出示例：\n![image](http://xiaobokeji-test.oss-cn-shenzhen.aliyuncs.com/upload/39f20ba0-fd66-fe24-8be1-fd8e5701ca49/npmrununit.png)\n\n\n参考链接：\n- [Jest](https://jestjs.io/)\n- [Vue单元测试](https://cn.vuejs.org/v2/guide/unit-testing.html)\n- [Vue_Test_Utils](https://vue-test-utils.vuejs.org/zh/)","tags":["单元测试"]},{"title":"请求封装","url":"%2F2018%2F03%2F29%2F%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%B0%81%E8%A3%85%2F","content":"\n目前后台是微服务架构，所以不同的业务模块会请求到不同的地址，而不同的环境（测试/beta/生产）会携带不同的请求头进行区分，同时每个请求都有固定的参数携带，所以需要对请求进行统一的封装和管理。在这里记录一下封装请求的代码。\n\n目前请求统一封装至 services 文件夹，按照后台模块名进行区分。每个请求都会封装成一个Promise，使用async/await进行异步请求管理。注意同时发起的多个请求使用Promise.all封装为一个新的Promise进行管理，防止串行请求影响性能。\n\n```\nlet resp = await OpService.getProjects()\nconsole.log(resp)\n\nlet requests = [UcService.getCurrentDeptLoginInfo(), UcService.getDepts()]\nlet [currentDeptResp, deptsResp] = await Promise.all(requests)\n\n```\n\n---\n\n# 1\n\n- utils/request.js\n- 封装请求\n\n```\n//module区分模块，模块名称封装在 【src/config/module.js】里\n//path 是请求的文件路径\n//data 是传入数据\n//noAccessToken 大部分时间都是false ，极端情况 比如登陆、投诉之类的不需要\n  get(module, path, data, noAccessToken = false) {\n    let p = new Promise(async function (resolve, reject) {\n      try {\n        let config = await BaseService.getConfig()\n        let client = await BaseService.getClient(module)\n        let services = config.services[module]\n        let resp = await client.get(makeUrl(services.host, path, data, noAccessToken), {\n          headers: {\n            accept: 'application/json',\n          }\n        })\n        resolve(resp)\n      } catch (e) {\n        await handleError(e)\n        reject(e)\n      }\n    })\n    return p\n  },\n```\n\n---\n\n# 2\n- eg: src\\services.js\n- 封装请求\n \n\n```\n/**\n * 登录后获取当前基础信息接口\n */\n \n //R是在build/webpack.base.conf.js里声明过的封装方法\n //里面包含了基础的请求信息\n \nfunction getCurrentDeptLoginInfo() {\n  let p = new Promise(async function (res, rej) {\n    try {\n      let resp = await R.get(Config.module.UC, '/user/get_current_dept_login_info')\n      res(resp)\n    } catch (e) {\n      rej(e)\n    }\n  })\n  return p\n}\n```\n\n---\n\n# 3 应用请求\n- src\\app.js\n- 调用封装的方法\n\n```\n   async handleDeptCommand(id) {\n      Loading.show()\n      try {\n        let resp = await UserService.switchDept(id)\n        if (resp.errcode == 0) {\n          let resp2 = await UserService.getCurrentDeptLoginInfo()\n          BaseService.setBasicData(resp2.info)\n          this._renderBasicData(resp2.info)\n          this.$router.push('/')\n        } else {\n          console.error(new Error('errcode: ' + resp.errcode))\n        }\n      } catch (e) {\n        console.error(e)\n      } finally {\n        Loading.hide()\n      }\n    }\n```\n","tags":["VUE"]},{"title":"前端页面内权限控制规范","url":"%2F2018%2F03%2F13%2F%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%86%85%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%A7%84%E8%8C%83%2F","content":"\n#### 201809更新\n\n`v-auth`控制弹窗内元素渲染会出现首次渲染成功后，第二次打开弹窗为false的情况，导致权限判断失败，页面样式错位，所以无法在弹窗内使用该方法。\n\n解决方法：因为只需要页面初次加载时判断用户有无功能权限，通过接口查询一次后赋值给data的xx属性，通过属性的值来判断。\n\n```\n  async created() {\n    // do someting\n\n    // 查询有无删除调账记录权限\n    try {\n      let valid = await this.fCheckAuth('household.HOUSEHOLD_DELSUBJECT')\n      if (valid) {\n        this.show_del = true\n      }\n    } catch (e) {\n      console.log(e)\n    }\n  },\n```\n---\n\n# 前端页面内权限控制规范\n\n目前的权限系统支持到动作点的细粒度控制，前端支持前置判断权限从而控制节点的展示与隐藏，执行相关逻辑等。前端通过 mixin 混入权限控制模块进行判断和处理。\n\n自定义组件需要单独`import '@/mixin/auth'`，如果是已经引入了`@/mixin`的页面组件则不需要额外引入该模块。\n\n该模块提供一个自定义指令`v-auth`和一个公共方法`fCheckAuth`，前者用来根据权限控制一个节点的展示或隐藏，后者通过该方法查询当前角色是否有某权限。\n\n---\n## 动作点管理\n\n动作点统一添加到`@/config/auth`。动作点通过模块管理，值为后台刷新的动作点名。\n\n```javascript\nexport default {\n  // 账单\n  bill: {\n    CONFIRM_OFFLINE_PAYMENT: 'accounting_billcenter_confirmofflinepayment' // 确认财务收款\n  }\n}\n```\n---\n## v-auth\n\n`v-auth`接收多种格式的参数。\n\n---\n### 传入字符串\n\n可以传入一个形如`'bill.CONFIRM_OFFLINE_PAYMENT'`的字符串，指令会到配置中寻找对应的路径查询当前动作点是否有权限，如果没有权限，则移除这个 DOM。\n\n注意：传入的是字符串`'bill.CONFIRM_OFFLINE_PAYMENT'`，而不是`bill.CONFIRM_OFFLINE_PAYMENT`，后者会被框架当做组件的`data`值去获取。\n\n---\n### 传入对象\n\n可以传入的是一个对象：\n\n| 参数名  | 类型    | 解释                                                                           |\n| ------- | ------- | ------------------------------------------------------------------------------ |\n| auth    | String  | 逻辑处理同字符串参数                                                           |\n| hide    | Boolean | 如果为`true`，则将其`display`属性置为`none`（而不是从 dom 中移除这个节点）     |\n| reverse | Boolean | 如果为`true`，则展示逻辑与正常相反，即无权限时展示该节点，有权限时移除这个节点 |\n---\n### 传入布尔值\n\n如果传入的是一个布尔值且该布尔值为`false`，则移除这个 DOM。作用同`v-if`。\n\n---\n## fCheckAuth()方法\n\n使用`this.fCheckAuth(auth)`方法判断当前是否有`auth`权限，`auth`参数同`v-auth`自定义指令接收的字符串参数。\n\n注意，这是一个异步方法。使用\n\n```javascript\nlet valid = await this.fCheckAuth('bill.CONFIRM_OFFLINE_PAYMENT')\nif (valid) {\n  // do something\n}\n```\n\n或者\n\n```javascript\nthis.fCheckAuth('bill.CONFIRM_OFFLINE_PAYMENT').then(valid => {\n  if (valid) {\n    // do something\n  }\n})\n```\n\n判断是否具有相关权限。","tags":["开发文档"]},{"title":"手动实现all、bind、apply","url":"%2F2017%2F09%2F23%2F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0all%E3%80%81bind%E3%80%81apply%2F","content":"\n\n###### call\n\n原生call\n\n```\nfunction test(arg1, arg2) {\n  console.log(arg1, arg2)\n  console.log(this.a, this.b)\n}\n\nrun.call({\n  a: 'a',\n  b: 'b'\n}, 1, 2)\n```\n\n在实现的过程有个关键：\n\n如果一个函数作为一个对象的属性，那么通过对象的.运算符调用此函数，**this** 就是此对象\n\n\n```\nlet obj = {\n  a: 'a',\n  b: 'b',\n  test: function (arg1, arg2) {\n    console.log(arg1, arg2)\n    // this.a 就是 a; this.b 就是 b\n    console.log(this.a, this.b) \n  }\n}\n\nobj.test(1, 2)\n\n```\n\n###### 手动模拟call\n\n\n```\nFunction.prototype.call2 = function(context) {\n  if(typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n\n  // 默认上下文是window\n  context = context || window\n  // 保存默认的fn\n  const { fn } = context\n\n  // 前面讲的关键，将函数本身作为对象context的属性调用，自动绑定this\n  context.fn = this\n  const args = [...arguments].slice(1)\n  const result = context.fn(...args)\n  \n  // 恢复默认的fn\n  context.fn = fn\n  return result\n}\n\n// 以下是测试代码\nfunction test(arg1, arg2) {\n  console.log(arg1, arg2)\n  console.log(this.a, this.b)\n}\n\ntest.call2({\n  a: 'a',\n  b: 'b'\n}, 1, 2)\n\n```\n\n###### bind\n\n`bind`有两个特点：\n- 本身返回一个全新的函数，所以需要考虑new的清空\n- 可以保留参数，内部实现了参数的拼接\n\n\n```\nFunction.prototype.bind2 = function(context) {\n  if(typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n\n  const that = this\n  // 保留之前的参数，为了下面的参数拼接\n  const args = [...arguments].slice(1)\n\n  return function F() {\n    // 如果被new创建实例，不会被改变上下文！\n    if(this instanceof F) {\n      return new that(...args, ...arguments)\n    }\n\t\n    // args.concat(...arguments): 拼接之前和现在的参数\n    // 注意：arguments是个类Array的Object, 用解构运算符..., 直接拿值拼接\n    return that.apply(context, args.concat(...arguments))\n  }\n}\n\n/**\n * 以下是测试代码\n */\n\nfunction test(arg1, arg2) {\n  console.log(arg1, arg2)\n  console.log(this.a, this.b)\n}\n\nconst test2 = test.bind2({\n  a: 'a',\n  b: 'b'\n}, 1) // 参数 1\n\ntest2(2) // 参数 2\n```\n\n###### apply\n\napply和call实现类似，只是传入的参数形式是数组形式，而不是逗号分隔的参数序列。\n\n因此，借助es6提供的...运算符，就可以很方便的实现数组和参数序列的转化。\n\n\n```\nFunction.prototype.apply2 = function(context) {\n  if(typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n\n  context = context || window\n  const { fn } = context\n\n  context.fn = this\n  let result\n  if(Array.isArray(arguments[1])) {\n    // 通过...运算符将数组转换为用逗号分隔的参数序列\n    result = context.fn(...arguments[1])\n  } else {\n    result = context.fn()\n  }\n\n  context.fn = fn\n  return result\n}\n\n/**\n * 以下是测试代码\n */\n\nfunction test(arg1, arg2) {\n  console.log(arg1, arg2)\n  console.log(this.a, this.b)\n}\n\ntest.apply2({\n  a: 'a',\n  b: 'b'\n}, [1, 2])\n```\n","tags":["面试"]},{"title":"记录hexo替换主题","url":"%2F2017%2F09%2F09%2F%E8%AE%B0%E5%BD%95hexo%E6%9B%BF%E6%8D%A2%E4%B8%BB%E9%A2%98%2F","content":"\n博客也是上线了一年了，结果拖拖拉拉一直没什么东西写，今天闲来无事想着更换看腻了的博客主题。在 [hexo主题官网](https://hexo.io/themes/) 找到了一款极简的主题 [polarbear](https://github.com/frostfan/hexo-theme-polarbear) ,安装替换现有主题都是常规流程。参考制作人的readme步骤。\n\n\n```\n$ npm install hexo-renderer-scss --save\n$ git clone https://github.com/frostfan/hexo-theme-polarbear themes/polarbear\n```\n\n---\n\n# 修改配置 **_config.yml**\n\n```\n# Extensions\n## Plugins: http://hexo.io/plugins/\n## Themes: http://hexo.io/themes/\ntheme: polarbear\n\n# 在归档页面显示所有文章 （Show all articles on archive page.）\n# 需要安装(Need to install) hexo-generator-archive 插件支持\narchive_generator:\n    per_page: 0\n    yearly: false\n    monthly: false\n    daily: false\n```\n\n结果 **archive** 和 **about** 遇到了问题。右上角的归档页和关于我找不到路径。\n\n![image](http://xiaobokeji-test.oss-cn-shenzhen.aliyuncs.com/upload/39f20625-eeef-cc03-1f9e-4d03778175c9/achite.png)\n\n---\n\n# 更换自己喜欢的网页图标\n\n网上搜索自己喜欢的图片，尺寸小，注意格式要是`.ico`,替换本地`themes`文件夹下的`favicon.icon`文件即可。\n\n---\n\n# 解决about找不到\n\n排查了一下问题，可能是文件找不到。终于找到了相关教程，new了文件\n\n```\nhexo new page \"about\"\nhexo new page \"archives\"\n```\n\n执行命令后在本地站点的source目录下生成一个about文件夹，修改about文件夹下的index.md。相应的archives也要修改type\n\n```\n---\ntitle: about\ndate: 2016-03-23 14:24:06\ntype: about\n---\n```\n\n```\n---\ntitle: archives\ndate: 2016-03-23 14:24:06\ntype: archive\n---\n\n```\n\n重启服务就发现about可以正常跳转一个空页了。\n\n---\n\n# 解决archive找不到\n百思不得其解为什么hexo没有自动生成archive，明明是安装了插件就可以支持的。重新执行了一下安装命令。\n```\nnpm install --save hexo-generator-archive\n```\n在node_modules下找到了相应的hexo-generator-archive，证明插件安装成功。但是还是没有自动生成。\n\n终于排查到了问题，**_config.yml** 网站配置文件里的文件目录写错了 \n\n```\n# 错误\narchive_dir: archive\n# 正确\narchive_dir: archives\n\n```\n\n终于成功了！\n\n![image](http://xiaobokeji-test.oss-cn-shenzhen.aliyuncs.com/upload/39f20628-f2aa-db19-1214-3dff2a83249e/%E6%B5%8B%E8%AF%95.png)\n\n---\n\n# 以下是9月10日更新：\n\n侧边栏没有展示自定义的widget\n\n修改本地站点的 **_config.yml** 的相关配置语句并没有生效，经过排查发现是主题的 **_config.yml** 的相关配置是false，看来主题的配置权重更高。修改为false之后就发现了自定义的 **widget_custom** 出现了。\n\n![image](http://xiaobokeji-test.oss-cn-shenzhen.aliyuncs.com/upload/39f20628-f2aa-db19-1214-3dff2a83249e/%E6%B5%8B%E8%AF%95.png)\n\n---\n\n\n参考文章 \n- [官方说明]( https://hexo.io/zh-cn/docs/configuration.html)\n- [Hexo安装配置详解](https://blog.csdn.net/tonydandelion2014/article/details/61615898)","tags":["hexo"]},{"title":"Element日期选择组件时间选择限定","url":"%2F2017%2F07%2F18%2FElement%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E7%BB%84%E4%BB%B6%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%E9%99%90%E5%AE%9A%2F","content":"\n\n# 2018 年 12 月更新：\n\n要求禁用时间不能小于启用时间。\n问题： 启用时间是动态更新的，不同数据启用时间不同，导致禁用时间范围也不一样。在data初始赋值后不会再更新pickerOptions\n解决方法：watch 启用时间，每次更新启用时间都动态更新一次pickerOptions\n\n# Template\n```\n<el-form-item label=\"启用月份\" prop=\"start_year_month\">\n    <el-date-picker\n      v-model=\"form.start_year_month\"\n      type=\"month\"\n      format=\"yyyy 年 MM\"\n      value-format=\"yyyyMM\"\n      style=\"width: 100%\"\n      placeholder=\"请选择启用月份\"\n      :clearable=\"false\"\n      :editable=\"false\"\n    ></el-date-picker>\n  </el-form-item>\n  <el-form-item\n    label=\"禁用月份\"\n    prop=\"stop_year_month\"\n  >\n    <el-date-picker\n      :picker-options=\"pickerOptions\"\n      v-model=\"form.stop_year_month\"\n      :clearable=\"false\"\n      :editable=\"false\"\n      type=\"month\"\n      style=\"width: 100%\"\n      format=\"yyyy 年 MM\"\n      value-format=\"yyyyMM\"\n      placeholder=\"请选择禁用月份\"\n    ></el-date-picker>\n  </el-form-item>\n```\n# Script\n\n```\ndata: {\n  pickerOptions: {},\n  form: {\n    start_year_month: '',\n    stop_year_month: ''\n  }\n}\n\nwatch: {\n  // time.getTime是把选中的时间转化成自1970年1月1日 00:00:00 UTC到当前时间的毫秒数\n  // 当前启用日期为 ‘201912’ ，只包含日期，导致return范围不对，需要转换为‘2019-12’\n  ['form.start_year_month'](val) {\n    this.pickerOptions = Object.assign({}, this.pickerOptions, {\n      // disabledDate 为true表示不可选,false表示可选\n      disabledDate: (time) => {\n      let str = val.slice(0, 4) + '-' + val.slice(4, 7)\n      str = new Date(str).getTime()\n      return time.getTime() < str  // 可选时间范围大于等于启用日期\n    }\n  })\n}\n```\n\n# 实现效果\n\n![image](http://xiaobokeji-test.oss-cn-shenzhen.aliyuncs.com/upload/39f20b94-1fa9-7f0c-547d-b353afaadf5e/1576142187330.gif)\n\n\n---\n\n# 2018 年 7 月更新：\n\n产品觉得饿了么的时间范围选择器不方便，要求使用两个单独的时间选择器做时间范围筛选。\n\n# Template\n```\n    <el-date-picker\n      v-model=\"startDate\"\n      type=\"date\"\n      placeholder=\"选择开始日期\"\n      :picker-options=\"pickerOptionsStart\"\n      @change=\"changeEnd\"\n    >\n    </el-date-picker>\n\n    <el-date-picker\n      v-model=\"endDate\"\n      type=\"date\"\n      placeholder=\"选择结束日期\"\n      :picker-options=\"pickerOptionsEnd\"\n      @change=\"changeStart\"\n    >\n    </el-date-picker>\n\n```\n\n# Script\n```\ndata() {\n      return {\n        pickerOptionsStart: {},\n        pickerOptionsEnd:{},\n        startDate: '',\n        endDate: '',\n      };\n\nmethods:{\n      changeStart (){\n        this.pickerOptionsStart = Object.assign({},this.pickerOptionsStart,{\n          disabledDate: (time) => {\n            return time.getTime() > this.endDate\n          }\n        })\n      },\n      changeEnd (){\n        this.pickerOptionsEnd = Object.assign({},this.pickerOptionsEnd,{\n          disabledDate: (time) => {\n            return time.getTime() < this.startDate\n            }\n        })\n      }\n    }\n```\n\n---\n\n##### 2018 年 4 月更新：\n\n做企业合同办理入住遇到新的需求，特此记录一下。\n\n```\nimport moment from 'moment'\nexport default function () {\n  let that = this\n  return {\n    /** *\n     * 不允许选择未来日期\n     * 允许选择合同开始前的30天,（即往前推29天）\n     * 如果合同租期已结束，可选最大时间为租期结束时间\n     */\n    pickerOptions: {\n      disabledDate(time) {\n        let curDate = (new Date()).getTime()\n        let start = new Date(that.form.rent_start).getTime()\n        let end = new Date(that.form.rent_end).getTime()\n        let three = 30 * 24 * 3600 * 1000\n        if (moment().isAfter(that.form.rent_end, 'day')) {\n          return time.getTime() < start - three || time.getTime() > end\n        }\n        return time.getTime() < start - three || time.getTime() > curDate\n      }\n    }\n  }\n```\n\n---\n\n##### 应用场景：\n\n双栏日期选择。选定开始日期后，结束日期只能限定在开始日期后三个月内的任意一天。\n\n##### 缺点:\n\n内部循环遍历所有日期，性能较差\n\n##### 代码：\n\n- datepick.html\n\n```\n<div id=\"datepick\">\n    <datepick></datepick>\n</div>\n```\n\n- datepick.vue\n\n```\n<template>\n    <div class=\"block\">\n            <el-date-picker\n                   v-model=\"value1\"\n                   type=\"date\"\n                   placeholder=\"开始日期\"\n                   :picker-options=\"pickerOptions0\">\n            </el-date-picker>\n            <el-date-picker\n                   v-model=\"value2\"\n                   type=\"date\"\n                   placeholder=\"结束日期\"\n                    :picker-options=\"pickerOptions1\">\n            </el-date-picker>\n    </div>\n</template>\n\n<script>\n    export default {\n        data(){\n            return {\n            value1:'',\n            value2:'',\n            pickerOptions1: {\n                //disabledDate是日期组件的一个方法\n                disabledDate: (time) => {\n                    //这里就涉及到日期的指定了  setMonth()函数可以设置月份\n                    let currentTime = this.value1;\n                    let threeMonths = currentTime.setMonth(currentTime.getMonth()+3);\n                    //一开始我没加下面减三个月的那个语句，他的值会一直累加\n                    currentTime.setMonth(currentTime.getMonth()-3)\n                    return time.getTime() < this.value1 || time.getTime() > threeMonths ;\n                    }\n                }\n            }\n        }\n    }\n    </script>\n```\n\n- datepick.js\n\n```\nimport Vue from 'vue';\nimport ElementUI from 'element-ui';\nimport 'element-ui/lib/theme-chalk/index.css';\nimport datepick from '../components/datepick.vue';\n\nVue.use(ElementUI);\n\nnew Vue({\n    el: \"#datepick\",\n    template:'<datepick/>',\n    components: {datepick}\n})\n```\n","tags":["Element"]},{"title":"元素水平垂直居中","url":"%2F2017%2F07%2F09%2F%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F","content":"- [方法一：position加margin](#1)\n- [方法二： diaplay:table-cell](#2)\n- [方法三：position加 transform](#3)\n- [方法四：flex;align-items: center;justify-content: center](#4)\n- [方法五：display:flex;margin:auto](#5)\n- [方法六：transfer -50%](#6)\n- [方法七：兼容低版本浏览器，不固定宽高](#7)\n\n#### 示例图\n\n![示例图](http://vky-test-oss.inboyu.com/upload/39e79077-c1de-6d5b-a697-c17158ad3ada.png)\n\n<span id=\"1\"></span>\n#### 1.position加margin\n父元素和子元素高宽都固定，使用绝对定位的方法居中\n```\n/**html**/\n<div class=\"parent\">\n    <div class=\"child\"></div>\n</div>\n\n/**css**/\n.parent {\n    width: 200px;\n    height: 200px;\n    background: yellow;\n    position: relative;\n}\n.child {\n    width: 100px;\n    height: 100px;\n    background: green;\n    margin: auto;\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n}\n```\n\n\n\n<span id=\"2\"></span>\n#### 2.display:tabel-cell\n父元素必须为tabel-cell，子元素必须为display：inline-block\n\n```\n<!-- html -->\n<div class=\"parent\">\n     <div class=\"child\"></div>\n</div>\n\n/*css*/\n.parent {\n    width: 200px;\n    height: 200px;\n    background: yellow;\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n}\n.child{\n    display: inline-block;\n    vertical-align: middle;\n    width: 100px;\n    height: 100px;\n    background: green;\n}\n```\n\n\n\n<span id=\"3\"></span>\n#### 3.position加 transform\n不需要考虑父元素的高宽，可以做自适应，但是子元素的高宽必须限定\n\n```\n<!-- html -->\n<div class=\"parent\">\n    <div class=\"child\"></div>\n</div>\n \n/* css */\n.parentss {\n    position: relative;\n    background: yellow;\n    width: 200px;\n    height: 200px;\n}\n.child {\n    position: absolute;\n    background: green;\n    top:50%;\n    left:50%;\n    -webkit-transform:translate(-50%,-50%);\n    transform:translate(-50%,-50%);\n    width: 100px;\n    height: 100px;\n}\n```\n\n\n\n<span id=\"4\"></span>\n#### 4.flex;alige-item:center;justify-content: center\n子元素和父元素都无需限定高宽，移动端兼容性良好\n\n```\n<!-- html -->\n<div class=\"parent\">\n    <div class=\"child\"></div>\n</div>\n\n/* css */\n.parent {\n    background: yellow;\n    width: 200px;\n    height: 200px;\n    display: flex; \n    align-items: center; \n    justify-content: center;\n}\n\n.child {\n    background: green;\n    width: 100px;\n    height: 100px;\n}\n```\n\n\n\n<span id=\"5\"></span>\n#### 5.display:flex;margin:auto\n兼容性没测试过，移动端适用\n\n```\n<!-- html -->\n<div class=\"parent\">\n    <div class=\"child\"></div>\n</div>\n\n/* css */\n.parent {\n    background: yellow;\n    width: 200px;\n    height: 200px;\n    display: flex; \n}\n\n.child {\n    background: green;\n    width: 100px;\n    height: 100px;\n    margin: auto;\n}\n```\n<span id=\"6\"></span>\n#### 6.tranfer -50%\n百分比来设置宽高\n\n```\n//vertical center\n.vertical-center{\n  position absolute\n  top 50%\n  transform translate(0,-50%)\n}\n.vertical-horizontal{\n  position absolute\n  left 50%\n  top 50%\n  transform translate(-50%,-50%)\n}\n```\n\n\n\n```\n<!-- html -->\n<div class=\"parent\">\n    <div class=\"child\"></div>\n</div>\n\n/* css */\n.parent {\n \n}\n\n.child {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width:50%;\n    height:30%;\n    padding:20px;\n    text-align:center;\n    background:#393;\n    color:#fff;\n    transform: translate(-50%, -50%);\n}\n```\n\n\n\n<span id=\"7\"><span>\n#### 7.高宽不定\n\n```\n<!-- html -->\n<div class=\"table\">\n    <div class=\"tableCell\">\n        <div class=\"content\">不固定宽高，自适应</div>\n    </div>\n</div>\n \n/*css*/\n.table {\n    height: 200px;/*高度值不能少*/\n    width: 200px;/*宽度值不能少*/\n    display: table;\n    position: relative;\n    float:left;\n    background: yellow;\n}      \n \n.tableCell {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;        \n    *position: absolute;\n    padding: 10px;\n    *top: 50%;\n    *left: 50%;\n}\n.content {\n    *position:relative;\n    *top: -50%;\n    *left: -50%;\n     background: green;\n}\n```\n","tags":["移动开发"]},{"title":"Vue中样式覆盖-style的scoped属性","url":"%2F2017%2F07%2F06%2FVue%E4%B8%AD%E6%A0%B7%E5%BC%8F%E8%A6%86%E7%9B%96-style%E7%9A%84scoped%E5%B1%9E%E6%80%A7%2F","content":"##### 背景\n  &emsp;项目使用Vue和ElementUi，想要覆盖ElementUi默认的输入框样式，新增自定义CSS样式，根据el-input编译后生成的class修改，但是样式并不生效。  \n 后来发现修改\n```\n<style type=\"text/css\" scoped></style>\n```\n标签里的<font color=\"#4bcc8e\">scoped</font>删除就生效了。  \n \n ##### 原因\n  &emsp;<font color=\"#4bcc8e\">scope</font>可以做到样式私有化，及当前样式只作用于当前模块，不会影响全局。\n \n &emsp;通过查看DOM结构发现：vue通过在DOM结构以及css样式上加唯一不重复的标记，以保证唯一，达到样式私有化模块化的目的。具体的渲染结果是怎样的，通过一个例子来说明。\n \n ##### 举个栗子\n \n &emsp;一个公共组件button，为了样式模块化，给其加上<font color=\"#4bcc8e\">scoped</font>属性\n \n```\n//button.vue\n<template>\n    <div class=\"button-warp\">\n        <button class=\"button\">text</button>\n    </div>\n</template>\n...\n<style scoped>\n    .button-warp{\n        display:inline-block;\n    }\n    .button{\n        padding: 5px 10px;\n        font-size: 12px;\n        border-radus: 2px;\n    }\n</style>\n```\n&emsp;浏览器渲染的button组件，其html和css结构如下：\n\n```\n<div data-v-2311c06a class=\"button-warp\">\n    <button data-v-2311c06a class=\"button\">text</button>\n</div>\n```\n\n```\n.button-warp[data-v-2311c06a]{\n    display:inline-block;\n}\n.button[data-v-2311c06a]{\n    padding: 5px 10px;\n    font-size: 12px;\n    border-radus: 2px;\n}\n```\n&emsp;从上面的案例可以看出，添加了<font color=\"#4bcc8e\">scoped</font>属性的组件，为了达到组件样式模块化，做了两个处理：\n\n- 给 `HTML `的 `DOM `节点加一个不重复data属性(形如：data-v-2311c06a)来表示他的唯一性\n- 在每句 `css `选择器的末尾（编译后的生成的css语句）加一个当前组件的data属性选择器（如[data-v-2311c06a]）来私有化样式\n\n&emsp;但这势必影响到css的优先级，<font color=\"#4bcc8e\">scoped</font>虽然达到了组件样式模块化，但是会导致每个样式的`权重加重`。理论上我们要修改这个样式的话，需要更高的权重去修改，增加了复杂度。\n\n##### 外部引用\n&emsp;栗子说明了单个组件渲染，当遇到组件相互调用，如果组件内部包含有其他组件，只会给其他组件的最外层标签加上当前组件的data属性。\n\n\n \n##### 解决方案\n&emsp;vue-loader的深度作用选择器。  \n \n&emsp;在vue.js中，`<style scoped>`的作用域在本`html`页面，`<style>`样式的作用域则是全局（即所有html页面），由于我把其中一个html页面的`<style scoped>`<font color=\"#4bcc8e\">scoped</font>去掉，这个页面的样式就变成了全局样式，当其它页面和这些全局样式重`class`名时，样式会被覆盖（vue默认全局样式覆盖局部样式），这样就导致当前页面定义样式影响到全局样式。\n\n&emsp;如何在`<style scoped>`局部样式中覆盖全局样式：父组件cssName+ /deep/+第三方库需要更改的cssName\n\n```\n比如修改class为el-input__inner的元素，\n它的父class为input_percent，\n则在style中写入input_percent /deep/ .el-input__inner {}即可\n```\n\n","tags":["Vue"]},{"title":"markdown语法","url":"%2F2017%2F03%2F09%2Fmarkdown%E8%AF%AD%E6%B3%95%2F","content":"- [强调](#1)\n- [分割线](#2)\n- [引用](#3)\n- [嵌套列表](#4)\n- [段落缩进（空格）](#5)\n- [字体、字号、颜色](#6)\n- [标签](#7)\n\n* 当前目录使用的索引超链的方式\n\n<span id = \"1\"></span>\n#### 强调\n\n```\n**强调文字**\n__强调文字__\n\n*强调文字\n强调文字*\n\n_强调文字_\n```\n**强调文字**\n__强调文字__\n\n*强调文字\n强调文字*\n\n_强调文字_\n\n<span id = \"2\"></span>\n#### 分割线\n\n```\n\n---\n\n```\n\n---\n<span id = \"3\"></span>\n#### 引用\n\n```\n>引用\n >>引用中的引用\n```\n>引用\n >>引用中的引用\n<span id = \"4\"></span>\n#### 嵌套列表\n\n```\n- 嵌套列表1\n + 嵌套列表2\n + 嵌套列表3\n  - 嵌套列表4\n   * 嵌套列表5\n- 嵌套列表6\n```\n- 嵌套列表1\n + 嵌套列表2\n + 嵌套列表3\n  - 嵌套列表4\n   * 嵌套列表5\n- 嵌套列表6\n\n\n<span id = \"5\"></span>\n#### 段落缩进\n\n```\n半方大的空白&ensp;或&#8194;看，飞碟\n全方大的空白&emsp;或&#8195;看，飞碟\n不断行的空白格&nbsp;或&#160;看，飞碟\n&emsp;&emsp;段落从此开始。\n```\n半方大的空白&ensp;或&#8194;看，飞碟\n\n全方大的空白&emsp;或&#8195;看，飞碟\n\n不断行的空白格&nbsp;或&#160;看，飞碟\n\n&emsp;&emsp;段落从此开始。\n\n<span id = \"6\"></span>\n#### 字体、字号、颜色\n\n```\n<font face=\"黑体\">我是黑体字</font>\n<font face=\"微软雅黑\">我是微软雅黑</font>\n<font face=\"STCAIYUN\">我是华文彩云</font>\n<font color=#0099ff size=12 face=\"黑体\">黑体</font>\n<font color=#00ffff size=3>null</font>\n<font color=gray size=5>gray</font>\n\n```\n<font face=\"黑体\">我是黑体字</font>\n\n<font face=\"微软雅黑\">我是微软雅黑</font>\n\n<font face=\"STCAIYUN\">我是华文彩云</font>\n\n<font color=#4bcc8e size=6 face=\"黑体\">黑体</font>\n\n<font color=#4bcc8e size=3>null</font>\n\n<font color=gray size=5>gray</font>\n\n<span id = \"7\"></span>\n#### 标签\n\n```\n行内标签`\n```\n这是一个有颜色的`标签`","tags":["学习"]}]