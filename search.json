[{"title":"手动实现all、bind、apply","url":"%2F2017%2F09%2F23%2F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0all%E3%80%81bind%E3%80%81apply%2F","content":"\n\n###### call\n\n原生call\n\n```\nfunction test(arg1, arg2) {\n  console.log(arg1, arg2)\n  console.log(this.a, this.b)\n}\n\nrun.call({\n  a: 'a',\n  b: 'b'\n}, 1, 2)\n```\n\n在实现的过程有个关键：\n\n如果一个函数作为一个对象的属性，那么通过对象的.运算符调用此函数，**this** 就是此对象\n\n\n```\nlet obj = {\n  a: 'a',\n  b: 'b',\n  test: function (arg1, arg2) {\n    console.log(arg1, arg2)\n    // this.a 就是 a; this.b 就是 b\n    console.log(this.a, this.b) \n  }\n}\n\nobj.test(1, 2)\n\n```\n\n###### 手动模拟call\n\n\n```\nFunction.prototype.call2 = function(context) {\n  if(typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n\n  // 默认上下文是window\n  context = context || window\n  // 保存默认的fn\n  const { fn } = context\n\n  // 前面讲的关键，将函数本身作为对象context的属性调用，自动绑定this\n  context.fn = this\n  const args = [...arguments].slice(1)\n  const result = context.fn(...args)\n  \n  // 恢复默认的fn\n  context.fn = fn\n  return result\n}\n\n// 以下是测试代码\nfunction test(arg1, arg2) {\n  console.log(arg1, arg2)\n  console.log(this.a, this.b)\n}\n\ntest.call2({\n  a: 'a',\n  b: 'b'\n}, 1, 2)\n\n```\n\n###### bind\n\n`bind`有两个特点：\n- 本身返回一个全新的函数，所以需要考虑new的清空\n- 可以保留参数，内部实现了参数的拼接\n\n\n```\nFunction.prototype.bind2 = function(context) {\n  if(typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n\n  const that = this\n  // 保留之前的参数，为了下面的参数拼接\n  const args = [...arguments].slice(1)\n\n  return function F() {\n    // 如果被new创建实例，不会被改变上下文！\n    if(this instanceof F) {\n      return new that(...args, ...arguments)\n    }\n\t\n    // args.concat(...arguments): 拼接之前和现在的参数\n    // 注意：arguments是个类Array的Object, 用解构运算符..., 直接拿值拼接\n    return that.apply(context, args.concat(...arguments))\n  }\n}\n\n/**\n * 以下是测试代码\n */\n\nfunction test(arg1, arg2) {\n  console.log(arg1, arg2)\n  console.log(this.a, this.b)\n}\n\nconst test2 = test.bind2({\n  a: 'a',\n  b: 'b'\n}, 1) // 参数 1\n\ntest2(2) // 参数 2\n```\n\n###### apply\n\napply和call实现类似，只是传入的参数形式是数组形式，而不是逗号分隔的参数序列。\n\n因此，借助es6提供的...运算符，就可以很方便的实现数组和参数序列的转化。\n\n\n```\nFunction.prototype.apply2 = function(context) {\n  if(typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n\n  context = context || window\n  const { fn } = context\n\n  context.fn = this\n  let result\n  if(Array.isArray(arguments[1])) {\n    // 通过...运算符将数组转换为用逗号分隔的参数序列\n    result = context.fn(...arguments[1])\n  } else {\n    result = context.fn()\n  }\n\n  context.fn = fn\n  return result\n}\n\n/**\n * 以下是测试代码\n */\n\nfunction test(arg1, arg2) {\n  console.log(arg1, arg2)\n  console.log(this.a, this.b)\n}\n\ntest.apply2({\n  a: 'a',\n  b: 'b'\n}, [1, 2])\n```\n","tags":["前端"]},{"title":"记录hexo替换主题","url":"%2F2017%2F09%2F09%2F%E8%AE%B0%E5%BD%95hexo%E6%9B%BF%E6%8D%A2%E4%B8%BB%E9%A2%98%2F","content":"\n#### 9月10日更新\n\n博客也是上线了一年了，结果拖拖拉拉一直没什么东西写，今天闲来无事想着更换看腻了的博客主题。在 [hexo主题官网](https://hexo.io/themes/) 找到了一款极简的主题 [polarbear](https://github.com/frostfan/hexo-theme-polarbear) ,安装替换现有主题都是常规流程。参考制作人的readme步骤。\n\n\n```\n$ npm install hexo-renderer-scss --save\n$ git clone https://github.com/frostfan/hexo-theme-polarbear themes/polarbear\n```\n修改配置 **_config.yml**\n\n```\n# Extensions\n## Plugins: http://hexo.io/plugins/\n## Themes: http://hexo.io/themes/\ntheme: polarbear\n\n# 在归档页面显示所有文章 （Show all articles on archive page.）\n# 需要安装(Need to install) hexo-generator-archive 插件支持\narchive_generator:\n    per_page: 0\n    yearly: false\n    monthly: false\n    daily: false\n```\n\n结果 **archive** 和 **about** 遇到了问题。右上角的归档页和关于我找不到路径。\n\n![image](http://xiaobokeji-test.oss-cn-shenzhen.aliyuncs.com/upload/39f20625-eeef-cc03-1f9e-4d03778175c9/achite.png)\n\n#### 解决about找不到\n\n排查了一下问题，可能是文件找不到。终于找到了相关教程，new了文件\n\n```\nhexo new page \"about\"\nhexo new page \"archives\"\n```\n\n执行命令后在本地站点的source目录下生成一个about文件夹，修改about文件夹下的index.md。相应的archives也要修改type\n\n```\n---\ntitle: about\ndate: 2016-03-23 14:24:06\ntype: about\n---\n```\n\n```\n---\ntitle: archives\ndate: 2016-03-23 14:24:06\ntype: archive\n---\n\n```\n\n重启服务就发现about可以正常跳转一个空页了。\n\n#### 解决archive找不到\n百思不得其解为什么hexo没有自动生成archive，明明是安装了插件就可以支持的。重新执行了一下安装命令。\n```\nnpm install --save hexo-generator-archive\n```\n在node_modules下找到了相应的hexo-generator-archive，证明插件安装成功。但是还是没有自动生成。\n\n终于排查到了问题，**_config.yml** 网站配置文件里的文件目录写错了 \n\n```\n# 错误\narchive_dir: archive\n# 正确\narchive_dir: archives\n\n```\n\n终于成功了！\n\n![image](http://xiaobokeji-test.oss-cn-shenzhen.aliyuncs.com/upload/39f20628-f2aa-db19-1214-3dff2a83249e/%E6%B5%8B%E8%AF%95.png)\n\n\n---\n以下是9月10日更新：\n\n#### 侧边栏没有展示自定义的widget\n\n修改本地站点的 **_config.yml** 的相关配置语句并没有生效，经过排查发现是主题的 **_config.yml** 的相关配置是false，看来主题的配置权重更高。修改为false之后就发现了自定义的 **widget_custom** 出现了。\n\n![image](http://xiaobokeji-test.oss-cn-shenzhen.aliyuncs.com/upload/39f20625-eeef-cc03-1f9e-4d03778175c9/achite.png)\n\n---\n\n\n参考文章 \n- [官方说明]( https://hexo.io/zh-cn/docs/configuration.html)\n- [Hexo安装配置详解](https://blog.csdn.net/tonydandelion2014/article/details/61615898)","tags":["hexo"]},{"title":"emoji的坑","url":"%2F2017%2F08%2F22%2Femoji%E7%9A%84%E5%9D%91%2F","content":"\n\n```\n从毕业以来，基本就一直在做移动端，但是一直就关于移动端的开发，各种适配问题的解决，在日常搬砖中处理了就过了，也没有把东西都沉淀下来，现就一个小bug，记录一下。\n```\n\n#### 背景\n\n之前在做一个留言功能时，发现在其中一台安卓5.0的手机上，输入emoji糊掉了，成了如下这样的情况 \n\n这是skr啥玩意儿呀。\n\n与是我又试了好几个手机，ios都没有问题，甚至一台安卓机中之霸（安卓4.0），随便进个页面都要加载十几秒的手机都没有问题，是乱码了吗？\n\n为啥emoji会出现乱码呢？相信很多人都遇到过关于emoji的问题，比如输入emoji，传给后端，再经过一系列操作后从接口中取到后端返回的emoji字符就乱了。又比如为了限制输入字数，给字符做截断时出现的问题。\n\n初步怀疑是编码问题，那我们就来看看emoji究竟是何方神圣。\n\n---\n\n#### emoji的历史\nemoji对于我们来说并不陌生，我们很早就开始接触它了。emoji这个词来源于日语里的“絵文字”（假名为“えもじ”，读音即emoji）。它是1999年，当时还在日本无线运营商NTT DoCoMo工作的Shigetaka Kurita（栗田穣崇）发明的。\n\n#### emoji的编码\nemoji虽然看上去是一个有颜色有形状的表情，但它属于计算机中的字符。在计算机中，我们把文字、标点符号、图形符号、数字等统一称为字符，由字符组成的集合，我们称为字符集。为了让计算机识别字符集里的字符，我们设计了一套字符集编码规则，比如ASCII码，由于ASCII只规定了128个字符的编码，随着计算机的发展，人们意识到这些编码显然是不够的，为了统一世界上的所有字符，诞生出了Unicode字符集，而emoji字符就是Unicode字符集中的一部分。\n\n#### Unicode\nUnicode从0开始，为每个符号指定一个编号，称做\"码点\"，如U+0000，U+表示紧跟在后面的十六进制数是Unicode的码点。Unicode只规定了每个字符的码点，到底用什么样的字节序表示这个码点，就涉及到编码方法，比如我们html上常用的UTF-8。关于不同的编码方法怎么表示Unicode，以及JavaScript是怎么处理Unicode，这里就不详细阐述了，可参考Unicode与JavaScript详解 链接地址：http://www.ruanyifeng.com/blog/2014/12/unicode.html\n\n所以emoji作为unicode，那在计算机上是怎么显示的？\n\n之前我在一微信群里@我一朋友，结果出现了下面的情况。\n\n\n\n@符号跑右边去了，当时觉得很奇怪，后来了解到，这是阿拉伯文，因为阿拉伯文的书写规则是从右向左，所以@符号跑到右边去了，可见微信对不同unicode字符排版做的兼容还挺好。再比如这几个字符，热҈得҈字҈出҈汗҈了҈。\n\n这就涉及到了复杂文字编排（Complex text layout，缩写：CTL）。要求复杂文字编排以适当显示的书写系统称为复杂文本，比如阿拉伯文字、婆罗米系文字的天城文、泰文等。\n\n拿泰文来说，根据拼写规则，泰文可形象地分为鞋子字符、主体字符、帽子字符、声调字符等。泰文的每个基本字符对应一个unicode码，人们在输入多个基本字符时，新输入的字符与之前的字符做匹配，如果可以组合，则这时前面的输入就拼合成了一个泰文字符然后显示出来。\n\n\n\n萨瓦迪卡～\n\n英文也是，我们在输入英文时会习惯以空格来拆分前后单词,你如果输入一串连续的英文字母，计算机在识别上也会有困难。phpisthebestlanguageintheworld（手动滑稽脸）这句话就很有争议！！\n\n人为可以轻松识别一个泰文是否拼写正确，但是计算机在显示时就很难判断。\n\n像泰文这种特殊合成字符的本质，你无法避免人们在计算机上都会有哪些奇妙的创造。\n\n于是乎，不同字符之间的组合，就诞生出了流行的颜文字：\n\nฅ՞•ﻌ•՞ฅ\n\nʕ•̼͛͡•ʕ-̺͛͡•ʔ•̮͛͡•ʔ\n\n(⑉꒦ິ^꒦ິ⑉)\n\n₊˚‧(๑σ̴̶̷̥́ ₃σ̴̶̷̀)·˚₊\n\n୧(๑•̀⌄•́๑)૭✧\n\n而字符的显示，还有一个影响就是字体，在浏览器中，如果对应的编码在字体文件中为空，一般会展示成□□□□，这样至少不会影响排版，但是unicode作为万国码实在太庞大了，在一些字体里，对一些特殊字符还是会产生一些错误的排版，唉҈～真҈是惆҈怅～～\n\n对于emoji来说，它虽然也是一种特殊字符，但它并不属于复杂文本，并且我是通过移动终端规范输入，排版也不会有什么问题。我设置的font-family在其他手机上是好的也说明，这些字体对输入的emoji也是支持的，出问题的终端上，非emoji的字体正常显示，那暂时可以排除字体对emoji的影响了。\n\n---\n\n#### 回归问题\n到这里，还没有解决我的问题。本来以为是常见问题，比如数据提交时或者数据库储存的编码问题。可是，我也没传给后端啊！我刚在自己的页面上输入显示就成这样了！\n\n可恶，这个锅甩不动了。还是得自己解决，我input框刚输入，本地看到就乱了，看来还是自己的问题。\n 我一气之下疯狂乱点，发现不同的表情对应的这些小虫长得还不一样，于是，我决定把它放大看一看\n\n 这不就是表情么，只是因为某些原因看上去被压缩了。我的表情啊，你到底是经历了什么才变得如此面目全非。我一定要找到毁你容的真凶。\n\n先分析一下表象，emoji的显示被截断、压缩。为什么被压缩？回归场景，移动端切图，那么移动端的多终端适配，可不可能是问题的原因？\n\n切图是UI给的以iphone6的屏幕宽度为准的750px2倍视觉稿，组内方案选择参考了手淘的flexible。具体原理和这次主题无关，我就不在这里阐述了。关于移动端多端适配方案的原理详细，可以参考 手淘H5页面的终端适配\n\n链接地址: https://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html\n\n那么哪些代码是影响emoji缩放的代码呢？最先想到的是，我的emoji在输入框里面，设置了font-size，这个font-size的值是rem, 那会不会是某些安卓系统emoji对rem支持不好？于是我换成px，依然如此。\n\n那么页面上还有哪儿还有会影响缩放呢？于是定位到了这里。\n\n\n```\n<meta name = \"viewport\" content=\"initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=0,width=device-width\"/>\n```\n\n\nviewport是我们设备屏幕上用来显示网页的区域，在移动端上，viewport一般都是大于浏览器可视区域。\n\n理论上，移动端有三个viewport。\n\nlayout viewport：移动浏览器为了让所有网站正常显示（包括那些PC的页面），把默认的viewport设为了一个较宽值，这个值一般都是大于移动端可视区（比如iPhone 980px）。也就是document.documentElement.clientWidth\n\nvisual viewport：代表浏览器可视区域的大小。也就是window.innerWidth\n\nideal viewport：能完美适配移动设备的viewport，用户不需要缩放和横向滚动条就能完美看到网页内容，并且文字图片，在不同分辨率屏幕下显示出来太小应该是差不多的（比如iPhone的ideal viewport宽度是320px）\n\n关于各个设备的ideal viewport 可以从这里查询，链接地址：http://viewportsizes.com/\n\n所以我们利用meta标签，设置viewport的宽度等于设备的宽度,并且不允许用户手动缩放。让viewport的宽度等于设备的宽度，这个应该就是我们想要的理想宽度。\n\n实际上，只设置initial-scale=1，我们也能把当前的viewport宽度变成ideal viewport的宽度（这里不考虑iphone下不同dpr的缩放），因为这个缩放就是相对于ideal viewport来进行缩放的。当同时设置了width与initial-scale=1，浏览器会选择两者中较大的那个值。\n\n说了这么多，那么我的问题出在哪儿呢？猜想是不是该安卓版本对设置width和initial-scale会有一些意想不到的问题，于是我去掉了width=device-width，保留initial-scale=1等属性，结果emoji竟然好了。\n\n所以我遇到的情况就是，同时设置了width=device-width和initial-scale=1，会造成某些厂商手机的安卓5.0（目前只遇到这个）emoji被拉伸，去掉width=device-width，（不写width=device-width也就是windows phone上的IE无论是横竖屏都把宽度设为竖屏时ideal viewport宽度，个人觉得这个无伤大雅），至于为什么会这样，我暂时只能深入到这啦 (╥╯^╰╥)\n\n---\n\n#### 结论\n每一个emoji，就是一个Unicode字符，由统一码联盟（The Unicode Consortium）来投票选拔和公布，世界各地的人们可以向联盟提交 emoji 提案。而统一码联盟的 emoji 规范，只是定义了某个字符的语义，再由 Emojipedia 这个网站对 emoji 进行描述表达，最后允许大家按照对描述的理解，自由地去设计图案。\n\n所以不同的厂商以及不同的系统，甚至浏览器、浏览器版本以及系统字体等，对emoji的支持程度与兼容性是不一样的。比如同一个emoji笑脸表情，在ios和安卓上显示的效果也不一样。为了统一emoji表情，很多公司都有自己的一套emoji mapping，来做Unicode码与emoji表情的映射。\n\n---\n\n#### 碎碎念\n移动端开发总会遇到各种问题，有时候做兼容也会遇到无法完全兼容两头的情况，这时只能放弃受众更小，选择兼容影响面、严重性更大的方案了。在解决问题的有时候深究下去，也会收获很多。\n","tags":["emoji"]},{"title":"Element日期选择组件时间选择限定","url":"%2F2017%2F07%2F18%2FElement%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E7%BB%84%E4%BB%B6%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%E9%99%90%E5%AE%9A%2F","content":"##### 2018年4月更新：\n\n做企业合同办理入住遇到新的需求，特此记录一下。\n\n```\nimport moment from 'moment'\nexport default function () {\n  let that = this\n  return {\n    /** *\n     * 不允许选择未来日期\n     * 允许选择合同开始前的30天,（即往前推29天）\n     * 如果合同租期已结束，可选最大时间为租期结束时间\n     */\n    pickerOptions: {\n      disabledDate(time) {\n        let curDate = (new Date()).getTime()\n        let start = new Date(that.form.rent_start).getTime()\n        let end = new Date(that.form.rent_end).getTime()\n        let three = 30 * 24 * 3600 * 1000\n        if (moment().isAfter(that.form.rent_end, 'day')) {\n          return time.getTime() < start - three || time.getTime() > end\n        }\n        return time.getTime() < start - three || time.getTime() > curDate\n      }\n    }\n  }\n```\n\n\n\n##### 应用场景：\n双栏日期选择。选定开始日期后，结束日期只能限定在开始日期后三个月内的任意一天。\n\n##### 缺点:\n内部循环遍历所有日期，性能较差\n\n##### 代码：\n\n- datepick.html \n\n```\n<div id=\"datepick\">\n    <datepick></datepick>\n</div>\n```\n\n- datepick.vue\n\n```\n<template>\n    <div class=\"block\">\n            <el-date-picker\n                   v-model=\"value1\"\n                   type=\"date\"\n                   placeholder=\"开始日期\"\n                   :picker-options=\"pickerOptions0\">\n            </el-date-picker>\n            <el-date-picker\n                   v-model=\"value2\"\n                   type=\"date\"\n                   placeholder=\"结束日期\"\n                    :picker-options=\"pickerOptions1\">\n            </el-date-picker>\n    </div>\n</template>\n\n<script>\n    export default {\n        data(){\n            return {\n            value1:'',\n            value2:'',\n            pickerOptions1: {\n                //disabledDate是日期组件的一个方法\n                disabledDate: (time) => {   \n                    //这里就涉及到日期的指定了  setMonth()函数可以设置月份              \n                    let currentTime = this.value1;\n                    let threeMonths = currentTime.setMonth(currentTime.getMonth()+3);   \n                    //一开始我没加下面减三个月的那个语句，他的值会一直累加                            \n                    currentTime.setMonth(currentTime.getMonth()-3)\n                    return time.getTime() < this.value1 || time.getTime() > threeMonths ; \n                    }\n                }\n            }      \n        }\n    }     \n    </script>\n```\n- datepick.js \n\n```\nimport Vue from 'vue';\nimport ElementUI from 'element-ui';\nimport 'element-ui/lib/theme-chalk/index.css';\nimport datepick from '../components/datepick.vue';\n\nVue.use(ElementUI);\n\nnew Vue({\n    el: \"#datepick\",\n    template:'<datepick/>',\n    components: {datepick}\n})\n```\n","tags":["Element"]},{"title":"Vue中样式覆盖-style的scoped属性","url":"%2F2017%2F07%2F06%2FVue%E4%B8%AD%E6%A0%B7%E5%BC%8F%E8%A6%86%E7%9B%96-style%E7%9A%84scoped%E5%B1%9E%E6%80%A7%2F","content":"##### 背景\n  &emsp;项目使用Vue和ElementUi，想要覆盖ElementUi默认的输入框样式，新增自定义CSS样式，根据el-input编译后生成的class修改，但是样式并不生效。  \n 后来发现修改\n```\n<style type=\"text/css\" scoped></style>\n```\n标签里的<font color=\"#4bcc8e\">scoped</font>删除就生效了。  \n \n ##### 原因\n  &emsp;<font color=\"#4bcc8e\">scope</font>可以做到样式私有化，及当前样式只作用于当前模块，不会影响全局。\n \n &emsp;通过查看DOM结构发现：vue通过在DOM结构以及css样式上加唯一不重复的标记，以保证唯一，达到样式私有化模块化的目的。具体的渲染结果是怎样的，通过一个例子来说明。\n \n ##### 举个栗子\n \n &emsp;一个公共组件button，为了样式模块化，给其加上<font color=\"#4bcc8e\">scoped</font>属性\n \n```\n//button.vue\n<template>\n    <div class=\"button-warp\">\n        <button class=\"button\">text</button>\n    </div>\n</template>\n...\n<style scoped>\n    .button-warp{\n        display:inline-block;\n    }\n    .button{\n        padding: 5px 10px;\n        font-size: 12px;\n        border-radus: 2px;\n    }\n</style>\n```\n&emsp;浏览器渲染的button组件，其html和css结构如下：\n\n```\n<div data-v-2311c06a class=\"button-warp\">\n    <button data-v-2311c06a class=\"button\">text</button>\n</div>\n```\n\n```\n.button-warp[data-v-2311c06a]{\n    display:inline-block;\n}\n.button[data-v-2311c06a]{\n    padding: 5px 10px;\n    font-size: 12px;\n    border-radus: 2px;\n}\n```\n&emsp;从上面的案例可以看出，添加了<font color=\"#4bcc8e\">scoped</font>属性的组件，为了达到组件样式模块化，做了两个处理：\n\n- 给 `HTML `的 `DOM `节点加一个不重复data属性(形如：data-v-2311c06a)来表示他的唯一性\n- 在每句 `css `选择器的末尾（编译后的生成的css语句）加一个当前组件的data属性选择器（如[data-v-2311c06a]）来私有化样式\n\n&emsp;但这势必影响到css的优先级，<font color=\"#4bcc8e\">scoped</font>虽然达到了组件样式模块化，但是会导致每个样式的`权重加重`。理论上我们要修改这个样式的话，需要更高的权重去修改，增加了复杂度。\n\n##### 外部引用\n&emsp;栗子说明了单个组件渲染，当遇到组件相互调用，如果组件内部包含有其他组件，只会给其他组件的最外层标签加上当前组件的data属性。\n\n\n \n##### 解决方案\n&emsp;vue-loader的深度作用选择器。  \n \n&emsp;在vue.js中，`<style scoped>`的作用域在本`html`页面，`<style>`样式的作用域则是全局（即所有html页面），由于我把其中一个html页面的`<style scoped>`<font color=\"#4bcc8e\">scoped</font>去掉，这个页面的样式就变成了全局样式，当其它页面和这些全局样式重`class`名时，样式会被覆盖（vue默认全局样式覆盖局部样式），这样就导致当前页面定义样式影响到全局样式。\n\n&emsp;如何在`<style scoped>`局部样式中覆盖全局样式：父组件cssName+ /deep/+第三方库需要更改的cssName\n\n```\n比如修改class为el-input__inner的元素，\n它的父class为input_percent，\n则在style中写入input_percent /deep/ .el-input__inner {}即可\n```\n\n","tags":["Vue"]},{"title":"markdown语法","url":"%2F2017%2F03%2F09%2Fmarkdown%E8%AF%AD%E6%B3%95%2F","content":"- [强调](#1)\n- [分割线](#2)\n- [引用](#3)\n- [嵌套列表](#4)\n- [段落缩进（空格）](#5)\n- [字体、字号、颜色](#6)\n- [标签](#7)\n\n* 当前目录使用的索引超链的方式\n\n<span id = \"1\"></span>\n#### 强调\n\n```\n**强调文字**\n__强调文字__\n\n*强调文字\n强调文字*\n\n_强调文字_\n```\n**强调文字**\n__强调文字__\n\n*强调文字\n强调文字*\n\n_强调文字_\n\n<span id = \"2\"></span>\n#### 分割线\n\n```\n\n---\n\n```\n\n---\n<span id = \"3\"></span>\n#### 引用\n\n```\n>引用\n >>引用中的引用\n```\n>引用\n >>引用中的引用\n<span id = \"4\"></span>\n#### 嵌套列表\n\n```\n- 嵌套列表1\n + 嵌套列表2\n + 嵌套列表3\n  - 嵌套列表4\n   * 嵌套列表5\n- 嵌套列表6\n```\n- 嵌套列表1\n + 嵌套列表2\n + 嵌套列表3\n  - 嵌套列表4\n   * 嵌套列表5\n- 嵌套列表6\n\n\n<span id = \"5\"></span>\n#### 段落缩进\n\n```\n半方大的空白&ensp;或&#8194;看，飞碟\n全方大的空白&emsp;或&#8195;看，飞碟\n不断行的空白格&nbsp;或&#160;看，飞碟\n&emsp;&emsp;段落从此开始。\n```\n半方大的空白&ensp;或&#8194;看，飞碟\n\n全方大的空白&emsp;或&#8195;看，飞碟\n\n不断行的空白格&nbsp;或&#160;看，飞碟\n\n&emsp;&emsp;段落从此开始。\n\n<span id = \"6\"></span>\n#### 字体、字号、颜色\n\n```\n<font face=\"黑体\">我是黑体字</font>\n<font face=\"微软雅黑\">我是微软雅黑</font>\n<font face=\"STCAIYUN\">我是华文彩云</font>\n<font color=#0099ff size=12 face=\"黑体\">黑体</font>\n<font color=#00ffff size=3>null</font>\n<font color=gray size=5>gray</font>\n\n```\n<font face=\"黑体\">我是黑体字</font>\n\n<font face=\"微软雅黑\">我是微软雅黑</font>\n\n<font face=\"STCAIYUN\">我是华文彩云</font>\n\n<font color=#4bcc8e size=6 face=\"黑体\">黑体</font>\n\n<font color=#4bcc8e size=3>null</font>\n\n<font color=gray size=5>gray</font>\n\n<span id = \"7\"></span>\n#### 标签\n\n```\n行内标签`\n```\n这是一个有颜色的`标签`"}]